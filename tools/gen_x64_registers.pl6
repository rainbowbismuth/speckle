# Copyright 2016 Emily A. Bellows
#
# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
# option. This file may not be copied, modified, or distributed
# except according to those terms.

use v6;

say q:to/END/;
// Copyright 2016 Emily A. Bellows
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// DO NOT MODIFY
// This file was generated by tools/gen_registers.pl6
END

my %registers;

sub reg-info(Str:D $name, Int:D $bits, Int:D $code, Bool:D :$ext=False, 
    Bool:D :$never-rex=False, Bool:D :$needs-rex=False, Str:D :$comment) {
    %registers{$name}<bits> = $bits;
    %registers{$name}<code> = $ext ?? $code + 8 !! $code;
    %registers{$name}<never-rex> = $never-rex;
    %registers{$name}<needs-rex> = $bits == 64 || $needs-rex || $ext;
    %registers{$name}<comment> = $comment;
}

for <AL CL DL BL>.pairs { 
    reg-info(.value, 8, .key, :comment(qq:to/END/));
    /// A 8-bit register. The low byte of the 16-bit register, `{.value.trans(<L> => <X>)}`.
    END
}

for <AH CH DH BH>.pairs {
    reg-info(.value, 8, .key + 4, :never-rex(True), :comment(qq:to/END/));
    /// A 8-bit register. The high byte of the 16-bit register, `{.value.trans(<H> => <X>)}`.
    ///
    /// Any instruction using a REX prefix CAN NOT access this register. So you can not combine the usage of `{.value}`
    /// with the `DIL`, `SIL`, `BPL`, or `SPL` registers. Nor the `R8L` to `R15L` registers.
    END
}

for <SPL BPL SIL DIL>.pairs {
    reg-info(.value, 8, .key + 4, :needs-rex(True), :comment(qq:to/END/));
    /// A 8-bit register. The low byte of the `{.value.substr(0, *-1)}` register.
    ///
    /// Available only in 64-bit mode.
    ///
    /// Any instruction using this register is encoded with a REX prefix, and so cannot be used with the
    /// `AH`, `CH`, `DH` or `BH` registers.
    END
}

for <R8B R9B R10B R11B R12B R13B R14B R15B>.pairs {
    reg-info(.value, 8, .key, :ext(True), :comment(qq:to/END/));
    /// A 8-bit register. The low byte of the 16-bit register, `{.value.trans(<B> => <W>)}`.
    ///
    /// Available only in 64-bit mode.
    ///
    /// Any instruction using this register is encoded with a REX prefix, and so cannot be used with the
    /// `AH`, `CH`, `DH` or `BH` registers.
    END
}

for <AX CX DX BX SP BP SI DI>.pairs {
    reg-info(.value, 16, .key, :comment(qq:to/END/));
    /// A 16-bit register. The low word of the 32-bit register, `{"E" ~ .value}`.
    END
}

for <R8W R9W R10W R11W R12W R13W R14W R15W>.pairs {
    reg-info(.value, 16, .key, :ext(True), :comment(qq:to/END/));
    /// A 16-bit register. The low word of the 32-bit register, `{.value.trans(<W> => <D>)}`.
    ///
    /// Available only in 64-bit mode.
    END
}

for <EAX ECX EDX EBX ESP EBP ESI EDI>.pairs {
    reg-info(.value, 32, .key, :comment(qq:to/END/));
    /// A 32-bit register. The low double word of the 64-bit register, `{.value.trans(<E> => <R>)}`.
    END
}

for <R8D R9D R10D R11D R12D R13D R14D R15D>.pairs {
    reg-info(.value, 32, .key, :ext(True), :comment(qq:to/END/));
    /// A 32-bit register. The low double word of the 64-bit register, `{.value.substr(0, *-1)}`.
    ///
    /// Available only in 64-bit mode.
    END
}

for <RAX RCX RDX RBX RSP RBP RSI RDI>.pairs {
    reg-info(.value, 64, .key, :comment(qq:to/END/));
    /// A 64-bit register.
    ///
    /// Available only in 64-bit mode.
    END
}

for <R8 R9 R10 R11 R12 R13 R14 R15>.pairs {
    reg-info(.value, 64, .key, :ext(True), :comment(qq:to/END/));
    /// A 64-bit register.
    ///
    /// Available only in 64-bit mode.
    END
}

say qq:to/END/.chomp;
/// A general purpose register.
#[derive(Copy, Clone, Debug)]
#[repr(u16)]
pub enum Register \{
END

sub reg-compare(Str:D $a, Str:D $b) returns Order:D {
    (%registers{$a}<bits> => %registers{$a}<code>) cmp (
        %registers{$b}<bits> => %registers{$b}<code>)
}

for %registers.keys.sort(&reg-compare) {
    my $size = (%registers{$_}<bits> >= 16) +
        (%registers{$_}<bits> >= 32) +
        (%registers{$_}<bits> >= 64);

    my $repr = %registers{$_}<code> + 
        (%registers{$_}<never-rex> +< 3) +
        (%registers{$_}<needs-rex> +< 4) +
        ($size +< 5);

    say %registers{$_}<comment>.chomp.indent(2);
    printf "\t%4s = 0b%010b,\n", $_, $repr;
}

say q:to/END/;
}

/// The size of a general purpose register.
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum Size {
    /// A byte, or 8-bits.
    B = 0,
    /// A word, or 16-bits.
    W = 1,
    /// A double word, or 32-bits.
    D = 2,
    /// A quad word, or 64-bits.
    Q = 3
}

impl Register {
    /// How to encode this register in three bits.
    ///
    /// ```
    /// use speckle::x64::Register;
    /// assert_eq!(Register::EAX.code(), 0);
    /// assert_eq!(Register::R9D.code(), 1);
    /// ```
    pub fn code(self) -> u8 {
        ((self as u16) & 0b111) as u8
    }

    /// Can this register never be used with a REX prefix? 
    ///
    /// ```
    /// use speckle::x64::Register;
    /// assert_eq!(Register::AL.never_rex(), false);
    /// assert_eq!(Register::AH.never_rex(), true);
    /// ```
    pub fn never_rex(self) -> bool {
        ((self as u16) >> 3) & 1 != 0
    }

    /// Does this register require some kind of REX prefix to encode?
    ///
    /// ```
    /// use speckle::x64::Register;
    /// assert_eq!(Register::CX.needs_rex(), false);
    /// assert_eq!(Register::SIL.needs_rex(), true);
    /// ```
    pub fn needs_rex(self) -> bool {
        ((self as u16) >> 4) & 1 != 0
    }

    /// Returns how big the register is.
    ///
    /// ```
    /// use speckle::x64::{Register, Size};
    /// assert_eq!(Register::RAX.size(), Size::Q);
    /// assert_eq!(Register::R8W.size(), Size::W);
    /// ```
    pub fn size(self) -> Size {
        match (((self as u16) >> 5) & 0b11) as u8 {
            0 => Size::B,
            1 => Size::W,
            2 => Size::D,
            3 => Size::Q,
            _ => unreachable!("Can't be reached because of the bitwise AND'")
        }
    }
}
END
