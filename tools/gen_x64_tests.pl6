# Copyright 2016 Emily A. Bellows
#
# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
# option. This file may not be copied, modified, or distributed
# except according to those terms.

use v6;

say q:to/END/;
// Copyright 2016 Emily A. Bellows
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// DO NOT MODIFY
// This file was generated by tools/gen_x64_tests.pl6

#![allow(non_snake_case)]

use super::*;
use super::Register::*;
END

sub compile(Str:D $asm) {
    LEAVE { 
        "delete_me.s".IO.unlink;
        "delete_me.o".IO.unlink;
        "delete_me.lst".IO.unlink;
    }
    spurt "delete_me.s", "_start:\n\t$asm";
    my $proc = run "nasm",  "-f", "macho64", "delete_me.s", "-l", "delete_me.lst", :err(True);
    fail if $proc.err.slurp-rest;
    "delete_me.lst".IO.slurp.chomp.lines.Array.pop ~~ 
        /\s* <xdigit>+ \s <xdigit>+ \s (<xdigit>+)/;
    my Str:D $str = ~$0;
    sprintf "[%s]", (0..$str.chars/2-1).map({"0x{$str.substr($_ * 2, 2)}"}).join(", ")
}

my @ops = <add or adc sbb and sub xor cmp>;
my @regs = <AL CL DL BL AH CH DH BH SPL BPL SIL DIL R8B R9B R10B R11B R12B R13B R14B R15B
            AX CX DX BX SP BP SI DI R8W R9W R10W R11W R12W R13W R14W R15W
            EAX ECX EDX EBX ESP EBP ESI EDI R8D R9D R10D R11D R12D R13D R14D R15D
            RAX RCX RDX RBX RSP RBP RSI RDI R8 R9 R10 R11 R12 R13 R14 R15>;
my %seen;

for 0..1000 {
    my ($op, $r1, $r2) = (@ops, @regs, @regs)>>.roll;
    my $asm = "$op $r1, $r2";

    next if %seen{$asm}:exists;
    %seen{$asm} = True;

    my $test_name = $asm.trans(" " => "_", "," => "_");

    my $res = compile($asm);

    say qq:to/END/.chomp;
    #[test]
    fn test_{$test_name}() \{
    END

    if !$res.defined {
        say qq:to/END/;
        let mut asm = Assembler::new(vec![]);
        assert!(asm.{$op}($r1, $r2).is_err());
    }
    END
    } else {
        say qq:to/END/;
        let mut asm = Assembler::new(vec![]);
        asm.{$op}($r1, $r2).unwrap();
        assert_eq!(asm.done().unwrap(), vec!{$res});
    }
    END
    }
}
